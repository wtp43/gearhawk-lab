global:
  cloud: other
  clusterName: talos
  deploymentEnvironment: production
otelCollectorEndpoint: "signoz-otel-collector.signoz.svc.cluster.local:4317"
otelInsecure: true
presets:
  kubernetesAttributes:
    enabled: true
    # presets.kubernetesAttributes.passthrough -- If true, agents will not make k8s API calls, do discovery, or extract metadata.
    passthrough: false
    extractMetadatas:
      - k8s.namespace.name
      - k8s.deployment.name
      - k8s.statefulset.name
      - k8s.daemonset.name
      - k8s.cronjob.name
      - k8s.job.name
      - k8s.node.name
      - k8s.node.uid
      - k8s.pod.name
      - k8s.pod.uid
      - k8s.pod.start_time

  hostMetrics:
    enabled: true
    collectionInterval: 30s
    scrapers:
      cpu:
        metrics:
          system.cpu.logical.count:
            enabled: true # Collect logical CPU count.
          system.cpu.physical.count:
            enabled: true # Collect physical CPU count.
  clusterMetrics:
    enabled: true
    collectionInterval: 30s
  k8sEvents:
    enabled: true
    namespaces: [] #
  otlpExporter:
    enabled: true
  logsCollection:
    enabled: true
    blacklist:
      enabled: true
      namespaces:
        - kube-system
    operators:
      # Drop health check logs
      - type: filter
        id: drop_health_checks
        expr: 'body matches ".*(/health|/healthz|/readyz|/livez).*"'
        drop_ratio: 1.0
  kubeletMetrics:
    enabled: true
    insecureSkipVerify: false
    collectionInterval: 30s
otelDeployment:
  config:
    receivers:
      httpcheck/rapid:
        targets:
          - endpoint: https://typesense.gearhawk.io/health
            method: GET
          - endpoint: https://api.gearhawk.io
            method: GET
        collection_interval: 10s
      postgresql/data-warehouse:
        endpoint: ${env:POSTGRESQL_DATA_WAREHOUSE_ENDPOINT}
        username: ${env:MONITORING_USERNAME}
        password: ${env:MONITORING_PASSWORD}
        collection_interval: 60s
        tls:
          insecure: true
        metrics:
          postgresql.database.locks:
            enabled: true
          postgresql.deadlocks:
            enabled: true
          postgresql.sequential_scans:
            enabled: true
      postgresql/hatchet:
        endpoint: ${env:POSTGRESQL_HATCHET_ENDPOINT}
        username: ${env:MONITORING_USERNAME}
        password: ${env:MONITORING_PASSWORD}
        collection_interval: 60s
        tls:
          insecure: true
        metrics:
          postgresql.database.locks:
            enabled: true
          postgresql.deadlocks:
            enabled: true
          postgresql.sequential_scans:
            enabled: true

    processors:
      batch:
        send_batch_size: 10000
        timeout: 10s
      resourcedetection/system:
        detectors: [system, k8snode]
        timeout: 5s
        system:
          hostname_sources: [os]

    service:
      pipelines:
        metrics/httpcheck:
          receivers: [httpcheck/rapid]
          processors: [batch]
          exporters: [otlp]
        metrics/postgresql:
          receivers:
            - postgresql/data-warehouse
            - postgresql/hatchet
          processors:
            - resourcedetection/system
            - batch
          exporters: [otlp]
